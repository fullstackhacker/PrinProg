
	printf("initialization\n");
	//initializations
	instr1 = head; 
	if(!head->next){ //2nd instruction doesn't exists
		ERROR("Not enough instructions to optimize\n"); 
		exit(EXIT_FAILURE); 
	} 
	instr2 = head->next; //2nd instruction
	if(!(head->next || head->next->next)){  //3rd instruction if it exists
		ERROR("Not enough instructions to optimize\n"); 
		exit(EXIT_FAILURE); 
	} 
	instr3 = head->next->next; //3rd instruction

	while(instr3){  //while not at the last instruction
		if(instr1->opcode == LOADI && instr2->opcode == LOADI){
			if(instr3->opcode == ADD){ 	
				int sum = instr1->field2 + instr2->field2;  //sum them up 
				Instruction *newI = (Instruction *)calloc(1, sizeof(Instruction)); 	// create a new instruction
				newI->opcode = LOADI;  //LOADI cause we want to store the sum as a constant
				newI->field1 = instr3->field1;  //we want it in the sum register
				newI->field2 = sum;  //the constant we want to store
				newI->prev = instr1->prev; //in the case of instr1 == head --> it'll just be null!
				newI->next = instr3->next;  //in the case of instr3 == last instruction int eh list --> it'll just be null!	
				if(instr1 == head){  //instr1 was the head, so we need to point the head at the new head
					head = newI;	
				} 
				//free em'
				free(instr1);
				free(instr2); 
				free(instr3);
				//set up new pointers
				if(!newI->next) break; //no "first" instruction --- done
				instr1 = newI->next; 
				if(!instr1->next) break; //no "second instruction ---  done
				instr2 = instr1->next; 
				if(!instr2->next) break; //no "third" instruction --- done 
				instr3 = instr2->next;
				continue;
			}
			if(instr3->opcode == SUB){ 	
				int diff = instr1->field2 - instr2->field2;  //difference
				Instruction *newI = (Instruction *)calloc(1, sizeof(Instruction)); 	// create a new instruction
				newI->opcode = LOADI;  //LOADI cause we want to store the sum as a constant
				newI->field1 = instr3->field1;  //we want it in the sum register
				newI->field2 = diff;  //the constant we want to store
				newI->prev = instr1->prev; //in the case of instr1 == head --> it'll just be null!
				newI->next = instr3->next;  //in the case of instr3 == last instruction int eh list --> it'll just be null!	
				if(instr1 == head){  //instr1 was the head, so we need to point the head at the new head
					head = newI;	
				} 
				//free em'
				free(instr1);
				free(instr2); 
				free(instr3);
				//set up new pointers
				if(!newI->next) break; //no "first" instruction --- done
				instr1 = newI->next; 
				if(!instr1->next) break; //no "second instruction ---  done
				instr2 = instr1->next; 
				if(!instr2->next) break; //no "third" instruction --- done 
				instr3 = instr2->next;
				continue;
			}
			if(instr3->opcode == MUL){ 
				int mul = instr1->field2 * instr2->field2; //multiplication
				Instruction *newI = (Instruction *)calloc(1, sizeof(Instruction)); 	// create a new instruction
				newI->opcode = LOADI;  //LOADI cause we want to store the sum as a constant
				newI->field1 = instr3->field1;  //we want it in the sum register
				newI->field2 = mul;  //the constant we want to store
				newI->prev = instr1->prev; //in the case of instr1 == head --> it'll just be null!
				newI->next = instr3->next;  //in the case of instr3 == last instruction int eh list --> it'll just be null!	
				if(instr1 == head){  //instr1 was the head, so we need to point the head at the new head
					head = newI;	
				} 
				//free em'
				free(instr1);
				free(instr2); 
				free(instr3);
				//set up new pointers
				//set up new pointers
				if(!newI->next) break; //no "first" instruction --- done
				instr1 = newI->next; 
				if(!instr1->next) break; //no "second instruction ---  done
				instr2 = instr1->next; 
				if(!instr2->next) break; //no "third" instruction --- done 
				instr3 = instr2->next;
				continue;
			}
			instr1 = instr1->next; 
			instr2 = instr2->next; 
			instr3 = instr3->next;
		} 
